--- node_modules/connect-redis/node_modules/redis/index.js
+++ node_modules/connect-redis/node_modules/redis/index.js
@@ -503,36 +503,13 @@ RedisClient.prototype.return_error = function (err) {
         this.should_buffer = false;
     }
 
-    if (command_obj && typeof command_obj.callback === "function") {
-        try {
-            command_obj.callback(err);
-        } catch (callback_err) {
-            // if a callback throws an exception, re-throw it on a new stack so the parser can keep going
-            process.nextTick(function () {
-                throw callback_err;
-            });
-        }
+    if (command_obj.callback) {
+        command_obj.callback(err);
     } else {
-        console.log("node_redis: no callback to send error: " + err.message);
-        // this will probably not make it anywhere useful, but we might as well throw
-        process.nextTick(function () {
-            throw err;
-        });
+        this.emit('error', err);
     }
 };
 
-// if a callback throws an exception, re-throw it on a new stack so the parser can keep going.
-// put this try/catch in its own function because V8 doesn't optimize this well yet.
-function try_callback(callback, reply) {
-    try {
-        callback(null, reply);
-    } catch (err) {
-        process.nextTick(function () {
-            throw err;
-        });
-    }
-}
-
 // hgetall converts its replies to an Object.  If the reply is empty, null is returned.
 function reply_to_object(reply) {
     var obj = {}, j, jl, key, val;
@@ -595,7 +572,7 @@ RedisClient.prototype.return_reply = function (reply) {
                 reply = reply_to_object(reply);
             }
 
-            try_callback(command_obj.callback, reply);
+            command_obj.callback(null, reply);
         } else if (exports.debug_mode) {
             console.log("no callback for reply: " + (reply && reply.toString && reply.toString()));
         }
@@ -618,8 +595,10 @@ RedisClient.prototype.return_reply = function (reply) {
                 }
                 // subscribe commands take an optional callback and also emit an event, but only the first response is included in the callback
                 // TODO - document this or fix it so it works in a more obvious way
+                // reply[1] can be null
+                var reply1String = (reply[1] === null) ? null : reply[1].toString();
                 if (command_obj && typeof command_obj.callback === "function") {
-                    try_callback(command_obj.callback, reply[1].toString());
+                    command_obj.callback(null, reply1String);
                 }
                 this.emit(type, reply[1].toString(), reply[2]); // channel, count
             } else {
